name: Deploy to Google Cloud E2

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:  # Permite trigger manual

# Previne deployments simult√¢neos
concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  DOCKER_IMAGE: orkestrai-api
  DOCKER_REGISTRY: ghcr.io/${{ github.repository_owner }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # S√≥ faz deploy em push ou workflow manual (n√£o em PRs)
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Display deployment info
        run: |
          echo "üöÄ Deploy triggered by: ${{ github.event_name }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üë§ Actor: ${{ github.actor }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üí¨ Message: ${{ github.event.head_commit.message }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Docker tags
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE }}
          tags: |
            type=sha,prefix=,format=short
            type=raw,value=latest
            type=raw,value=prod-{{date 'YYYYMMDD-HHmmss'}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Copy deployment files to GCP E2 instance
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.GCP_HOST }}
          username: ${{ secrets.GCP_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          port: ${{ secrets.GCP_SSH_PORT || 22 }}
          source: "docker-compose.prod.yml,env.template,scripts/migrate_database.sh,migrations/"
          target: "/home/${{ secrets.GCP_USERNAME }}/orkestrai-api"
          strip_components: 0
          timeout: 3m

      - name: Deploy on GCP E2 instance
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.GCP_HOST }}
          username: ${{ secrets.GCP_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          port: ${{ secrets.GCP_SSH_PORT || 22 }}
          command_timeout: 20m
          script: |
            set -euo pipefail
            
            DEPLOY_DIR="/home/${{ secrets.GCP_USERNAME }}/orkestrai-api"
            IMAGE_NAME="${{ env.DOCKER_IMAGE }}"
            REGISTRY_IMAGE="${{ env.DOCKER_REGISTRY }}/${{ env.DOCKER_IMAGE }}"
            GIT_SHA="${{ github.sha }}"
            SHORT_SHA="${GIT_SHA:0:7}"
            
            cd "$DEPLOY_DIR"
            
            echo "================================================"
            echo "üöÄ Starting deployment - Commit: $SHORT_SHA"
            echo "================================================"
            
            # Verificar se .env existe
            if [ ! -f .env ]; then
              echo "‚ö†Ô∏è  Creating .env from template..."
              cp env.template .env
              echo "‚ùå ERROR: Please configure .env file with your settings!"
              exit 1
            fi
            
            # Carregar vari√°veis de ambiente de forma segura
            # Filtra coment√°rios, linhas vazias e exporta apenas vari√°veis v√°lidas
            set -a
            while IFS= read -r line || [ -n "$line" ]; do
              # Ignora linhas vazias e coment√°rios
              [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
              # Ignora linhas que n√£o s√£o vari√°veis (formato VAR=valor)
              [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$ ]] || continue
              # Exporta a vari√°vel
              export "${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
            done < .env
            set +a
            
            # Salvar imagem atual para rollback
            CURRENT_IMAGE=$(docker inspect --format='{{.Config.Image}}' orkestrai-api 2>/dev/null | tr -d '\n\r' | xargs || echo "none")
            echo "üì¶ Current image: '$CURRENT_IMAGE'"
            
            # Fun√ß√£o de rollback
            rollback() {
              echo "‚ùå Deployment failed! Starting rollback..."
              if [ "$CURRENT_IMAGE" != "none" ] && [ -n "$CURRENT_IMAGE" ]; then
                echo "üîÑ Restoring previous image: '$CURRENT_IMAGE'"
                docker stop orkestrai-api 2>/dev/null || true
                docker rm orkestrai-api 2>/dev/null || true
                docker compose -f docker-compose.prod.yml up -d --no-deps api 2>/dev/null || true
                echo "‚úÖ Rollback completed"
              else
                echo "‚ö†Ô∏è  No previous image to rollback to"
              fi
              exit 1
            }
            
            # Configurar trap para rollback em caso de erro
            trap rollback ERR
            
            # Login no GitHub Container Registry
            echo "üîê Logging in to GitHub Container Registry..."
            echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
            
            # Pull da nova imagem
            echo "üì• Pulling new Docker image..."
            docker pull "${REGISTRY_IMAGE}:${SHORT_SHA}"
            docker tag "${REGISTRY_IMAGE}:${SHORT_SHA}" "${REGISTRY_IMAGE}:latest"
            
            # Criar tag local para compatibilidade com docker-compose
            docker tag "${REGISTRY_IMAGE}:latest" "${IMAGE_NAME}:latest"
            
            echo "‚úÖ Docker image pulled successfully"
            
            # Iniciar/verificar servi√ßos de infraestrutura
            echo "üîß Starting infrastructure services..."
            docker compose -f docker-compose.prod.yml up -d postgres redis
            
            # Aguardar container do PostgreSQL existir e estar rodando
            echo "‚è≥ Waiting for PostgreSQL container to start..."
            CONTAINER_WAIT=30
            CONTAINER_ELAPSED=0
            until docker ps --filter "name=agents_postgres" --filter "status=running" | grep -q agents_postgres; do
              if [ $CONTAINER_ELAPSED -ge $CONTAINER_WAIT ]; then
                echo "‚ùå PostgreSQL container failed to start after ${CONTAINER_WAIT}s"
                echo "üîç Container status:"
                docker ps -a | grep postgres
                echo "üìã Docker logs:"
                docker logs agents_postgres 2>&1 || echo "Container not found"
                exit 1
              fi
              echo "  Waiting for container... (${CONTAINER_ELAPSED}s/${CONTAINER_WAIT}s)"
              sleep 2
              CONTAINER_ELAPSED=$((CONTAINER_ELAPSED + 2))
            done
            echo "‚úÖ PostgreSQL container is running"
            
            # Aguardar PostgreSQL estar pronto para conex√µes (com timeout)
            echo "‚è≥ Waiting for PostgreSQL to accept connections..."
            
            # Obter credenciais do .env com fallback para defaults
            PG_USER="${POSTGRES_USER:-agentuser}"
            PG_DB="${POSTGRES_DB:-agentsdb}"
            
            echo "üîç Testing connection with user: $PG_USER, database: $PG_DB"
            
            TIMEOUT=60
            ELAPSED=0
            until docker exec agents_postgres pg_isready -U "$PG_USER" -d "$PG_DB" > /dev/null 2>&1; do
              if [ $ELAPSED -ge $TIMEOUT ]; then
                echo "‚ùå PostgreSQL timeout after ${TIMEOUT}s"
                echo "üìã PostgreSQL logs:"
                docker logs --tail 50 agents_postgres
                echo ""
                echo "üîç Container status:"
                docker inspect agents_postgres --format='{{.State.Status}}: {{.State.Health.Status}}' || docker ps -a | grep postgres
                exit 1
              fi
              echo "  Tentativa $((ELAPSED / 2 + 1))/$((TIMEOUT / 2))..."
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            done
            echo "‚úÖ PostgreSQL is ready and accepting connections"
            
            # Aguardar container do Redis existir e estar rodando
            echo "‚è≥ Waiting for Redis container to start..."
            REDIS_CONTAINER_WAIT=30
            REDIS_CONTAINER_ELAPSED=0
            until docker ps --filter "name=agents_redis" --filter "status=running" | grep -q agents_redis; do
              if [ $REDIS_CONTAINER_ELAPSED -ge $REDIS_CONTAINER_WAIT ]; then
                echo "‚ùå Redis container failed to start after ${REDIS_CONTAINER_WAIT}s"
                echo "üîç Container status:"
                docker ps -a | grep redis
                echo "üìã Docker logs:"
                docker logs agents_redis 2>&1 || echo "Container not found"
                exit 1
              fi
              echo "  Waiting for container... (${REDIS_CONTAINER_ELAPSED}s/${REDIS_CONTAINER_WAIT}s)"
              sleep 2
              REDIS_CONTAINER_ELAPSED=$((REDIS_CONTAINER_ELAPSED + 2))
            done
            echo "‚úÖ Redis container is running"
            
            # Verificar Redis est√° aceitando conex√µes
            echo "‚è≥ Waiting for Redis to accept connections..."
            REDIS_TIMEOUT=30
            REDIS_ELAPSED=0
            REDIS_PASS="${REDIS_PASSWORD:-}"
            
            until docker exec agents_redis redis-cli --no-auth-warning -a "$REDIS_PASS" ping > /dev/null 2>&1; do
              if [ $REDIS_ELAPSED -ge $REDIS_TIMEOUT ]; then
                echo "‚ùå Redis timeout after ${REDIS_TIMEOUT}s"
                echo "üìã Redis logs:"
                docker logs --tail 50 agents_redis
                echo ""
                echo "üîç Container status:"
                docker inspect agents_redis --format='{{.State.Status}}: {{.State.Health.Status}}' || docker ps -a | grep redis
                exit 1
              fi
              echo "  Tentativa $((REDIS_ELAPSED / 2 + 1))/$((REDIS_TIMEOUT / 2))..."
              sleep 2
              REDIS_ELAPSED=$((REDIS_ELAPSED + 2))
            done
            echo "‚úÖ Redis is ready and accepting connections"
            
            # Executar migrations
            echo "üîÑ Running database migrations..."
            if ! docker run --rm \
              --entrypoint "" \
              --network agents_network \
              --env-file .env \
              -v "$(pwd)/migrations:/app/migrations:ro" \
              -v "$(pwd)/scripts:/app/scripts:ro" \
              "${IMAGE_NAME}:latest" \
              bash -x /app/scripts/migrate_database.sh; then
              echo "‚ùå Database migrations failed!"
              echo "üìã Checking migration script logs..."
              docker logs --tail 50 agents_postgres 2>&1 || true
              exit 1
            fi
            echo "‚úÖ Database migrations completed successfully"
            
            # Parar e remover container antigo (se existir)
            echo "üõë Stopping old container..."
            if docker ps -a | grep -q orkestrai-api; then
              docker stop orkestrai-api 2>/dev/null || true
              docker rm orkestrai-api 2>/dev/null || true
              echo "‚úÖ Old container removed"
            else
              echo "‚ÑπÔ∏è  No old container to remove"
            fi
            
            # Iniciar novo container
            echo "üöÄ Starting new application container..."
            docker compose -f docker-compose.prod.yml up -d --no-deps api
            
            # Aguardar novo container ficar saud√°vel
            echo "üè• Waiting for new container health check..."
            HEALTH_TIMEOUT=60
            HEALTH_ELAPSED=0
            until [ "$(docker inspect --format='{{.State.Health.Status}}' orkestrai-api 2>/dev/null)" = "healthy" ]; do
              if [ $HEALTH_ELAPSED -ge $HEALTH_TIMEOUT ]; then
                echo "‚ùå Health check timeout"
                docker logs --tail 50 orkestrai-api
                exit 1
              fi
              CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' orkestrai-api 2>/dev/null || echo "unknown")
              echo "  Container status: $CONTAINER_STATUS (${HEALTH_ELAPSED}s/${HEALTH_TIMEOUT}s)"
              sleep 3
              HEALTH_ELAPSED=$((HEALTH_ELAPSED + 3))
            done
            
            # Remover trap de rollback (deployment bem sucedido)
            trap - ERR
            
            # Limpar containers e imagens antigas
            echo "üßπ Cleaning up old resources..."
            docker image prune -f
            
            # Manter apenas √∫ltimas 3 vers√µes
            docker images "${IMAGE_NAME}" --format "{{.Tag}}" | grep -v "latest" | tail -n +4 | xargs -r -I {} docker rmi "${IMAGE_NAME}:{}" 2>/dev/null || true
            
            echo "================================================"
            echo "‚úÖ Deployment completed successfully!"
            echo "üìù Deployed version: $SHORT_SHA"
            echo "üåê API URL: http://$(hostname -I | awk '{print $1}'):8001"
            echo "================================================"

      - name: Verify deployment and run smoke tests
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.GCP_HOST }}
          username: ${{ secrets.GCP_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          port: ${{ secrets.GCP_SSH_PORT || 22 }}
          command_timeout: 5m
          script: |
            set -euo pipefail
            
            echo "üîç Running post-deployment verification..."
            
            # Verificar se container est√° rodando
            if ! docker ps | grep -q orkestrai-api; then
              echo "‚ùå Container is not running!"
              docker logs --tail 100 orkestrai-api
              exit 1
            fi
            
            # Verificar status do container
            HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' orkestrai-api 2>/dev/null || echo "none")
            echo "üìä Health status: $HEALTH_STATUS"
            
            if [ "$HEALTH_STATUS" != "healthy" ]; then
              echo "‚ùå Container is not healthy!"
              docker logs --tail 100 orkestrai-api
              exit 1
            fi
            
            # Smoke tests - testar endpoints principais
            echo "üß™ Running smoke tests..."
            
            # Test 1: Health endpoint
            if curl -f -s http://localhost:8001/health > /dev/null 2>&1; then
              echo "‚úÖ Health endpoint OK"
            else
              echo "‚ö†Ô∏è  Health endpoint check failed"
            fi
            
            # Test 2: Docs endpoint
            if curl -f -s http://localhost:8001/docs > /dev/null 2>&1; then
              echo "‚úÖ Docs endpoint OK"
            else
              echo "‚ö†Ô∏è  Docs endpoint check failed"
            fi
            
            # Mostrar estat√≠sticas do container
            echo ""
            echo "üìà Container stats:"
            docker stats orkestrai-api --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
            
            # Mostrar √∫ltimas linhas de log
            echo ""
            echo "üìã Recent logs:"
            docker logs --tail 20 orkestrai-api
            
            echo ""
            echo "‚úÖ All verification checks passed!"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "================================================"
            echo "‚úÖ DEPLOYMENT SUCCESSFUL!"
            echo "================================================"
            echo "üìù Commit: ${{ github.sha }}"
            echo "üë§ Deployed by: ${{ github.actor }}"
            echo "‚è∞ Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "================================================"
          else
            echo "================================================"
            echo "‚ùå DEPLOYMENT FAILED!"
            echo "================================================"
            echo "üìù Commit: ${{ github.sha }}"
            echo "üë§ Attempted by: ${{ github.actor }}"
            echo "‚è∞ Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "================================================"
            echo ""
            echo "‚ö†Ô∏è  Please check the logs above for details."
            echo "üí° The previous version should still be running (rollback executed)."
          fi
