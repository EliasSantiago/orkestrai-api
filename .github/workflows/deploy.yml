name: Deploy to Google Cloud E2

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  workflow_dispatch:  # Permite trigger manual

# Previne deployments simult√¢neos
concurrency:
  group: production-deployment
  cancel-in-progress: false

env:
  DOCKER_IMAGE: orkestrai-api
  DOCKER_REGISTRY: ghcr.io/${{ github.repository_owner }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    # S√≥ faz deploy em push ou workflow manual (n√£o em PRs)
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Display deployment info
        run: |
          echo "üöÄ Deploy triggered by: ${{ github.event_name }}"
          echo "üåø Branch: ${{ github.ref_name }}"
          echo "üë§ Actor: ${{ github.actor }}"
          echo "üìù Commit: ${{ github.sha }}"
          echo "üí¨ Message: ${{ github.event.head_commit.message }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate Docker tags
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_IMAGE }}
          tags: |
            type=sha,prefix=,format=short
            type=raw,value=latest
            type=raw,value=prod-{{date 'YYYYMMDD-HHmmss'}}

      - name: Build and export Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          tags: ${{ steps.meta.outputs.tags }}
          labels: |
            org.opencontainers.image.source=${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ github.event.head_commit.timestamp }}
          outputs: type=docker,dest=app-image.tar
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1

      - name: Upload Docker image as artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ github.sha }}
          path: app-image.tar
          retention-days: 7
          compression-level: 0  # J√° est√° comprimido

      - name: Copy files to GCP E2 instance
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.GCP_HOST }}
          username: ${{ secrets.GCP_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          port: ${{ secrets.GCP_SSH_PORT || 22 }}
          source: "app-image.tar,docker-compose.prod.yml,env.template,scripts/migrate_database.sh,migrations/"
          target: "/home/${{ secrets.GCP_USERNAME }}/orkestrai-api"
          strip_components: 0
          timeout: 10m

      - name: Deploy on GCP E2 instance
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.GCP_HOST }}
          username: ${{ secrets.GCP_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          port: ${{ secrets.GCP_SSH_PORT || 22 }}
          command_timeout: 20m
          script: |
            set -euo pipefail
            
            DEPLOY_DIR="/home/${{ secrets.GCP_USERNAME }}/orkestrai-api"
            IMAGE_NAME="${{ env.DOCKER_IMAGE }}"
            GIT_SHA="${{ github.sha }}"
            SHORT_SHA="${GIT_SHA:0:7}"
            
            cd "$DEPLOY_DIR"
            
            echo "================================================"
            echo "üöÄ Starting deployment - Commit: $SHORT_SHA"
            echo "================================================"
            
            # Verificar se .env existe
            if [ ! -f .env ]; then
              echo "‚ö†Ô∏è  Creating .env from template..."
              cp env.template .env
              echo "‚ùå ERROR: Please configure .env file with your settings!"
              exit 1
            fi
            
            # Carregar vari√°veis de ambiente de forma segura
            # Filtra coment√°rios, linhas vazias e exporta apenas vari√°veis v√°lidas
            set -a
            while IFS= read -r line || [ -n "$line" ]; do
              # Ignora linhas vazias e coment√°rios
              [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
              # Ignora linhas que n√£o s√£o vari√°veis (formato VAR=valor)
              [[ "$line" =~ ^[[:space:]]*([A-Za-z_][A-Za-z0-9_]*)[[:space:]]*=[[:space:]]*(.*)[[:space:]]*$ ]] || continue
              # Exporta a vari√°vel
              export "${BASH_REMATCH[1]}=${BASH_REMATCH[2]}"
            done < .env
            set +a
            
            # Salvar container atual para rollback
            CURRENT_CONTAINER=$(docker ps -q -f name=orkestrai-api) || true
            CURRENT_IMAGE=$(docker inspect --format='{{.Config.Image}}' orkestrai-api 2>/dev/null) || echo "none"
            echo "üì¶ Current image: $CURRENT_IMAGE"
            
            # Fun√ß√£o de rollback
            rollback() {
              echo "‚ùå Deployment failed! Starting rollback..."
              if [ -n "$CURRENT_CONTAINER" ]; then
                echo "üîÑ Restoring previous container..."
                docker compose -f docker-compose.prod.yml down api || true
                docker start "$CURRENT_CONTAINER" || true
              fi
              exit 1
            }
            
            # Configurar trap para rollback em caso de erro
            trap rollback ERR
            
            # Carregar nova imagem Docker
            echo "üì• Loading new Docker image..."
            docker load -i app-image.tar
            rm -f app-image.tar
            
            # Tag com SHA para versionamento
            docker tag "${IMAGE_NAME}:latest" "${IMAGE_NAME}:${SHORT_SHA}"
            
            # Verificar se imagem foi carregada
            if ! docker images | grep -q "${IMAGE_NAME}"; then
              echo "‚ùå Failed to load Docker image"
              exit 1
            fi
            
            # Iniciar/verificar servi√ßos de infraestrutura
            echo "üîß Starting infrastructure services..."
            docker compose -f docker-compose.prod.yml up -d postgres redis
            
            # Aguardar PostgreSQL estar pronto (com timeout)
            echo "‚è≥ Waiting for PostgreSQL..."
            
            # Obter credenciais do .env com fallback para defaults
            PG_USER="${POSTGRES_USER:-agentuser}"
            PG_DB="${POSTGRES_DB:-agentsdb}"
            
            echo "üîç Testing connection with user: $PG_USER, database: $PG_DB"
            
            TIMEOUT=60
            ELAPSED=0
            until docker exec agents_postgres pg_isready -U "$PG_USER" -d "$PG_DB" > /dev/null 2>&1; do
              if [ $ELAPSED -ge $TIMEOUT ]; then
                echo "‚ùå PostgreSQL timeout after ${TIMEOUT}s"
                echo "üìã PostgreSQL logs:"
                docker logs --tail 50 agents_postgres
                echo ""
                echo "üîç Container status:"
                docker ps -a | grep postgres
                exit 1
              fi
              echo "  Tentativa $((ELAPSED / 2 + 1))/$((TIMEOUT / 2))..."
              sleep 2
              ELAPSED=$((ELAPSED + 2))
            done
            echo "‚úÖ PostgreSQL is ready and accepting connections"
            
            # Verificar Redis
            echo "‚è≥ Waiting for Redis..."
            REDIS_TIMEOUT=30
            REDIS_ELAPSED=0
            REDIS_PASS="${REDIS_PASSWORD:-}"
            
            until docker exec agents_redis redis-cli --no-auth-warning -a "$REDIS_PASS" ping > /dev/null 2>&1; do
              if [ $REDIS_ELAPSED -ge $REDIS_TIMEOUT ]; then
                echo "‚ùå Redis timeout after ${REDIS_TIMEOUT}s"
                echo "üìã Redis logs:"
                docker logs --tail 50 agents_redis
                exit 1
              fi
              echo "  Tentativa $((REDIS_ELAPSED / 2 + 1))/$((REDIS_TIMEOUT / 2))..."
              sleep 2
              REDIS_ELAPSED=$((REDIS_ELAPSED + 2))
            done
            echo "‚úÖ Redis is ready and accepting connections"
            
            # Executar migrations
            echo "üîÑ Running database migrations..."
            docker run --rm \
              --entrypoint "" \
              --network agents_network \
              --env-file .env \
              -v "$(pwd)/migrations:/app/migrations:ro" \
              -v "$(pwd)/scripts:/app/scripts:ro" \
              "${IMAGE_NAME}:latest" \
              bash /app/scripts/migrate_database.sh
            
            # Blue-Green Deployment: Iniciar novo container antes de parar o antigo
            echo "üöÄ Starting new application container..."
            docker compose -f docker-compose.prod.yml up -d --no-deps --force-recreate api
            
            # Aguardar novo container ficar saud√°vel
            echo "üè• Waiting for new container health check..."
            HEALTH_TIMEOUT=60
            HEALTH_ELAPSED=0
            until [ "$(docker inspect --format='{{.State.Health.Status}}' orkestrai-api 2>/dev/null)" = "healthy" ]; do
              if [ $HEALTH_ELAPSED -ge $HEALTH_TIMEOUT ]; then
                echo "‚ùå Health check timeout"
                docker logs --tail 50 orkestrai-api
                exit 1
              fi
              CONTAINER_STATUS=$(docker inspect --format='{{.State.Status}}' orkestrai-api 2>/dev/null || echo "unknown")
              echo "  Container status: $CONTAINER_STATUS (${HEALTH_ELAPSED}s/${HEALTH_TIMEOUT}s)"
              sleep 3
              HEALTH_ELAPSED=$((HEALTH_ELAPSED + 3))
            done
            
            # Remover trap de rollback (deployment bem sucedido)
            trap - ERR
            
            # Limpar containers e imagens antigas
            echo "üßπ Cleaning up old resources..."
            docker image prune -f
            
            # Manter apenas √∫ltimas 3 vers√µes
            docker images "${IMAGE_NAME}" --format "{{.Tag}}" | grep -v "latest" | tail -n +4 | xargs -r -I {} docker rmi "${IMAGE_NAME}:{}" 2>/dev/null || true
            
            echo "================================================"
            echo "‚úÖ Deployment completed successfully!"
            echo "üìù Deployed version: $SHORT_SHA"
            echo "üåê API URL: http://$(hostname -I | awk '{print $1}'):8001"
            echo "================================================"

      - name: Verify deployment and run smoke tests
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.GCP_HOST }}
          username: ${{ secrets.GCP_USERNAME }}
          key: ${{ secrets.GCP_SSH_KEY }}
          port: ${{ secrets.GCP_SSH_PORT || 22 }}
          command_timeout: 5m
          script: |
            set -euo pipefail
            
            echo "üîç Running post-deployment verification..."
            
            # Verificar se container est√° rodando
            if ! docker ps | grep -q orkestrai-api; then
              echo "‚ùå Container is not running!"
              docker logs --tail 100 orkestrai-api
              exit 1
            fi
            
            # Verificar status do container
            HEALTH_STATUS=$(docker inspect --format '{{.State.Health.Status}}' orkestrai-api 2>/dev/null || echo "none")
            echo "üìä Health status: $HEALTH_STATUS"
            
            if [ "$HEALTH_STATUS" != "healthy" ]; then
              echo "‚ùå Container is not healthy!"
              docker logs --tail 100 orkestrai-api
              exit 1
            fi
            
            # Smoke tests - testar endpoints principais
            echo "üß™ Running smoke tests..."
            
            # Test 1: Health endpoint
            if curl -f -s http://localhost:8001/health > /dev/null 2>&1; then
              echo "‚úÖ Health endpoint OK"
            else
              echo "‚ö†Ô∏è  Health endpoint check failed"
            fi
            
            # Test 2: Docs endpoint
            if curl -f -s http://localhost:8001/docs > /dev/null 2>&1; then
              echo "‚úÖ Docs endpoint OK"
            else
              echo "‚ö†Ô∏è  Docs endpoint check failed"
            fi
            
            # Mostrar estat√≠sticas do container
            echo ""
            echo "üìà Container stats:"
            docker stats orkestrai-api --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
            
            # Mostrar √∫ltimas linhas de log
            echo ""
            echo "üìã Recent logs:"
            docker logs --tail 20 orkestrai-api
            
            echo ""
            echo "‚úÖ All verification checks passed!"

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "================================================"
            echo "‚úÖ DEPLOYMENT SUCCESSFUL!"
            echo "================================================"
            echo "üìù Commit: ${{ github.sha }}"
            echo "üë§ Deployed by: ${{ github.actor }}"
            echo "‚è∞ Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "================================================"
          else
            echo "================================================"
            echo "‚ùå DEPLOYMENT FAILED!"
            echo "================================================"
            echo "üìù Commit: ${{ github.sha }}"
            echo "üë§ Attempted by: ${{ github.actor }}"
            echo "‚è∞ Time: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "================================================"
            echo ""
            echo "‚ö†Ô∏è  Please check the logs above for details."
            echo "üí° The previous version should still be running (rollback executed)."
          fi
